<!DOCTYPE html>
<html>
	<head>
	<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
		<link rel="stylesheet" type="text/css" href="style.css">
		<link rel="stylesheet" type="text/css" href="prism.css">

		<title>Computing Presentation</title>
	</head>

	<body>
		<script src="prism.js"></script>
		<header>
			<div class="row">
				<div class="col-xs-12">
					<h1 class="header">Computer Science Presentation</h1>
				</div>
			</div>

			<!-- navbar -->
			<nav class="navbar navbar-inverse">
				<div class="container-fluid">
					<div class="navbar-header">
						<a class="navbar-brand" href="index.html">Home</a>
					</div>

					<ul class="nav navbar-nav">
						<li><a href="encryption.html">Encryption</a></li>
						<li><a href="security.html">Network Security</a><li>
						<li><a href="algorithms.html">Algorithm Efficiency</a></li>
					</ul>
				</div>
			</nav>
		</header>
		
		<section>
			<div class="container">
				<h2 class="center">Algorithm Efficiency - Big O Notation</h2>

				<div class="top row">
					<div class="col-xs-12 top">
						<p class="body-text top center-gravity">
							Big O notation is a mathematical notation that is used to classify algorithms by how their running time and space requirements change as the input grows. Big O specifically describes the worst case scenario of how much memory and time is required by the algorithm.
						</p>
					</div>
				</div>
				
				<div class="row">
					<h3 class="algorithm-subtitle">Constant Time  - O(1):</h3>
					
					<p class="body-text">
						O(1) describes an algorithm that will always have the same execution time and will use the same amount of resources.
					</p>
					
					<pre>
						<code class="language-java">
							boolean isFirstElementNull(int[] elements) {
							
								return elements[0] == null;
							}
						</code>
					</pre>
					
					<p class="body-text">
						This code sample will always execute in the same time because the algorithm does not change depending on different data sets. Therefore, the notation for this is: O(1).
					</p>
					
					<h3 class="algorithm-subtitle">Linear Time - O(N):</h3>
					
					<p class="body-text">
						The notation O(N) describes an algorithm that's performance will increase linearly  and in proportion to the data set used with it.
					</p>
					
					<pre>
						<code class="language-java">
							boolean containsValue(int[] elements, int value) {
							
								for (int element : elements) {
								
									if (element == value) return true;
									
									}
								}
								
								return false;
							}
						</code>
					</pre>
					
					<p class="body-text">
						This algorithm scans an array of integers and will return 'true' if one of the elements is equal to a specific value. This algorithm has an efficiency of O(N) (where N is represents the size of the data set) because the larger the data set, the longer it will take for the algorithm to find the value. <br/><br/>
						
						Although the algorithm could potentially find the value in the first instance of the loop, ending the function early, Big O notation represents the worst case scenario and always assumes that the algorithm will take as long as possible to complete.
					</p>
					
					<h3 class="algorithm-subtitle">Quadratic Time - O(N<sup>2</sup>)</h3>
					
					<p class="body-text">
						O(N<sup>2</sup>) represents an algorithm with a performance that is directly proportional to the square of the size of the data set. Quadratic time is commonly associated with algorithms that has nested iterations over the data set. Multiple iterations can result in O(N<sup>3</sup>), O(N<sup>4</sup>), etc.
					</p>
					
					<pre>
						<code class="language-java">
							boolean containsDuplicates(int[] elements) {
							
								for (var outer = 0; outer &#62 elements.length; outer++) {
								
									for (var inner = 0; inner &#62 elements.length; inner++) {
									
										if (!(outer == inner)) {
											
											if (elements[outer] == elements[inner]) return true;
										}
									}
								}
								
								return false;
							}
						</code>
					</pre>
					
					<p class="body-text">
						This algorithm iterates through the data set (an array of integers) twice, and as long as the two counters aren't equal (to prevent the algorithm checking an integer against itself), checks to see that integer has a duplicate.
						<br/><br/>
						
						This algorithm has a complexity of O(N<sup>2</sup>) because each time the outer loop iterates, the inner loop executes N times. This makes the if statement that checks the duplicate execute N*N times, which is equal to N<sup>2</sup>. Further iterations will cause the complexity to have a higher power.
						<br/><br/>
						
						An example of an algorithm that has the complexity of quadratic time is insertion sort. These algorithms are generally better off avoided because the execution time grows rapidly with a larger data set.
					</p>
					
					<h3 class="algorithm-subtitle">Exponential Time - O(2<sup>N</sup>):</h3>
					
					<p class="body-text">
						O(2<sup>N</sup>) represents an algorithm that grows exponentially. The growth will double with each added piece of data in the data set being used. The curve of an exponential algorithm starts off shallow and rises incredibly quickly.
					</p>

					<pre>
						<code class="language-java">
							int fibonacci(int number) {
							
								if(number &#60= 1) return number;
								
								return fibonacci(number - 2) + fibonacci(number - 1);
							}
						</code>
					</pre>
					
					<p class="body-text">
						This is an algorithm that calculates Fibonacci numbers. Because it uses recursion, the algorithm's complexity is exponential time. Algorithms like these are usually only suitable if the data set being used is appropiately small because the time required to execute the algorithm increases incredibly rapidly as the data set grows.
					</p>
					
					<h3 class="algorithm-subtitle">Logarithmic Time - O(log N)</h3>
					
					<p class="body-text">
						Logarithmic time is essentially the opposite of an exponential algorithm. With logarithmic algorithms, the time/memory required to execute is reduced as N (the data set) grows larger.
						<br/><br/>
						
						Logarithmic algorithms are identifiable by when variables are constantly halved or doubled. An example of this is a binary search. This algorithm complexity is desirable because the algorithm remains viable even with large data sets.
					</p>
				</div>
				
				<div class="row">
					<div class="col-xs-1"></div>
					
					<div class="col-xs-10">
						<h3 class="algorithm-subtitle center-gravity">Big O Notation Complexity Chart</h3>
						<p class="body-text">
						As shown in the graph below, the most desirable complexities are constant time (obviously) and logarithmic time because the time they take to execute does not become out of control as the input data set increases, unlike quadratic or exponential time.
					</p>
						<img class="image-center" src="assets/bigO.png">
						
					</div>
					
					<div class="col-xs-1"></div>
			</div>
		</section>
	</body>
</html>